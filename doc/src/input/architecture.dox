/*!
\page page_architecture Architecture
\tableofcontents

\section arch_overall General architecture overview

The library is writted in standard C++ (currently 14) and can be compiled using
Visual studio (2015 and 2017) and GCC (tested on Ubuntu 16.04) as well.

\subsection arch_overall_build Build

Build is executed using cross-platform make tool CMake (<https://cmake.org/>).<br>
CMake also integrates packaging system to provide one-click installable packages for each platform.<br>

Currently supported package systems:
<ul>
<li>Windows [<b>.msi</b>](https://en.wikipedia.org/wiki/Windows_Installer)
<li>Debian [<b>.deb</b>](https://en.wikipedia.org/wiki/Deb_(file_format))
<li>Red Hat Package Manager [<b>.rpm</b>](https://en.wikipedia.org/wiki/Rpm_(software))
</ul>

\subsection arch_overall_interface Interface

It provides only <b>ANSI C</b> API.<br>
The reason why I did not expose native C++ interface is rooted within the incompatibility of the C++ ABI between compilers.<br>
Functions across the interface use standard C caller clean-up [<b>cdecl</b>](https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl) calling convention.<br>

\section arch_errors Error handling

Library uses C++ exceptions internally.<br>
Each interface function is wrapped inside try-catch block to prevent any exceptions to escape and potentially crash the application.<br>

This is example, how interface functions usually look like:

\code
error_type Buffer_SetData(BufferHandle* handle, string_type data, size_type size) {
	Buffer* obj = reinterpret_cast<Buffer*>(handle);
	
	if (obj == nullptr) {
		return VANILLAPDF_ERROR_PARAMETER_VALUE;
	}
	
	if (data == nullptr) {
		return VANILLAPDF_ERROR_PARAMETER_VALUE;
	}

	try
	{
		obj->assign(data, data + size);
		return VANILLAPDF_ERROR_SUCCESS;
	} catch (std::exception& e) {
		// Store the error message
		return VANILLAPDF_ERROR_GENERAL;
	} catch (...) {
		return VANILLAPDF_ERROR_GENERAL;
	}
}
\endcode

\note The wrapping try-catch should have [negligible performance impact](https://en.wikipedia.org/wiki/Exception_handling#Exception_handling_implementation) on most compilers.

\subsection arch_errors_messages Error codes and messages

All exceptions thrown in this way are caught and their message is stored in a thread-local buffer.<br>
This buffer is separate for each thread and has a pre-allocated size in case of memory shortage.<br>

Following code snippet declares the structures that carries error information:
\code
	thread_local uint32_t m_error;
	thread_local size_type m_message_length;
	thread_local char m_message[constant::MAX_MESSAGE_SIZE];
\endcode

\section object_ownership Object ownership

All handles are basically opaque pointers to internal structures.<br>
Library uses so-called intrusive pointer reference counting mechanism.<br>
Usually, the structure and the reference counter are two separate objects.<br>
In this case, the reference counter is embedded inside the structure body.<br>

\image html intrusive_pointers.png "Picture 1: Illustration of embedding and intrusive pointer"

\subsection arch_ownership_comparison Intrusive vs Shared

Let's compare intrusive pointer with the traditional [C++ shared pointers](http://en.cppreference.com/w/cpp/memory/shared_ptr).<br>

Transferring object handle outside library bounds is more clear.<br>

\code
Buffer* buffer = new Buffer();
*result = reinterpret_cast<BufferHandle*>(buffer);

...

Buffer* buffer = reinterpret_cast<Buffer*>(handle);
\endcode

Intrusive pointers can guarantee, that there are no multiple reference count objects.<br>

\note
There is a nice try to address this issue called [shared_from_this](http://en.cppreference.com/w/cpp/memory/enable_shared_from_this).<br>
This could act as a help, but there is no guarantee.<br>

Intrusive pointers should have a better performance (in some cases) comparing to traditional C++ shared pointers.<br>
Main reason is that whole object is allocated within a single allocation, while shared pointers are often not.<br>

\note
Shared pointer can be allocated using [make_shared](http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared).<br>
Sometimes, the need to move object on heap is not known in advance, making is even more difficult to use.<br>

\section file_layer File layer

File layer allows access to file contents at the syntactic level.<br>
It has some necessary semantic features that are required for parsing its syntax.<br>

For example \ref IndirectObjectReferenceHandle often has to be resolved to read an object.<br>
The \ref StreamObjectHandle has it's \p Length often stored as an indirect object.<br>
In order to validate this object, the \p Length has to be resolved to successfully parse an object.<br>

\subsection arch_streams IO Streams

Library uses C++ io streams for reading source files and writing output files.<br>
There are already interfaces, that represents these streams and will be used throughout the library interface.<br>

<ul>
<li>Source files with \ref InputStreamInterfaceHandle
<li>Destination files with \ref OutputStreamInterfaceHandle
</ul>

\note
These interfaces could be overriden in the future, so that user can provide custom implementation for reading source file.<br>
This is often helpful for interacting with other applications, that might need to share file access.<br>

\subsection arch_parsing Parsing

Tokens are smallest syntactic elements and are separated by a whitespace or a delimiter.<br>
Which characters are considered whitespace and which are considered delimiter is discussed in [<b>section 7.2 - Lexical Conventions</b>](PDF32000_2008.pdf#G6.1638740).<br>

\note
PDF supports comments, but they are currently ignored. They might be persisted in the future.

Tokenizer uses look-ahead to determine proper token type, since some of the tokens are ambiguous from the first character.<br>
For example hexadecimal string is enclosed with angle brackets "<", ">" and the dictionary "<<", ">>".<br>

Sample parsing loop for hexadecimal string:
\code
int char = m_stream->Get();
if (char == Delimiter::LESS_THAN_SIGN) {

	int ahead = m_stream->Peek();
	if (ahead == Delimiter::LESS_THAN_SIGN) {
		return Token::Type::DICTIONARY_BEGIN;
	}

	for (;;) {
		int hex_char = m_stream->Get();
		if (hex_char == Delimiter::GREATER_THAN_SIGN) {
			break;
		}
		
		if (IsNumeric(hex_char) || IsAlpha(hex_char)) {
			continue;
		}
		
		// Found unknown character - terminate
	}

	return Token::Type::HEXADECIMAL_STRING;
}
\endcode

Tokens are passed to the parser, who is responsible for constructing objects.<br>
Parser uses look-ahead as well, since multiple tokens may form a single object.<br>

\image html indirect_reference_parsing.png "Picture 2: Diagram for parsing indirect object references"

\section function_callbacks Function callbacks

Library provides multiple interfaces, that could be overriden by the calling application.

For instance, when signing a document, it is possible to use classic PKCS#12 (Personal Information Exchange described in [<b>RFC 7292</b>](https://tools.ietf.org/html/rfc7292)).<br>
Unfortunately, this would not work with smart cards, where the private key is not directly accessible.<br>
User can override \ref SigningKeyHandle and provide signing implementation outside library boundaries.<br>

More extendable interfaces:
<ul>
<li>Document signing with \ref SigningKeyHandle
<li>Document encryption with \ref EncryptionKeyHandle
</ul>

\section arch_deps Dependencies

Library has three dependent libraries:
<ul>
<li>OpenSSL (<https://www.openssl.org/>) - used for encrypted files
<li>zlib (<http://www.zlib.net/>) - used for flate compression method
<li>libjpeg (<http://libjpeg.sourceforge.net/>) - used for compressed JPEG images
</ul>

*/